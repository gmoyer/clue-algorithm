<!DOCTYPE html>
<html>
<head>
<script>
//=======================Java====================
const cardNames = [
    "Mustard",
    "Plum",
    "Green",
    "Peacock",
    "Scarlet",
    "White",
    "Knife",
    "Candlestick",
    "Pistol",
    "Rope",
    "Lead Pipe",
    "Wrench",
    "Hall",
    "Lounge",
    "Dining Room",
    "Kitchen",
    "Ball Room",
    "Conservatory",
    "Billiard Room",
    "Library",
    "Study"
];
class Card {
    constructor(index) {
        this.index = index; //int
        this.name = cardNames[index]; //string
        if (index < 6) {
            this.type = 0;
            this.count = 6;
        } else if (index < 12) {
            this.type = 1;
            this.count = 6;
        } else {
            this.type = 2;
            this.count = 9;
        }
        this.odds = []; //scenarios where card exists in i player's hand
        this.odd = 0; //scenarios where card is a chosen card
        this.inHand = false; //in the player's hand
    }
}

class Player {
    constructor(num) {
        this.name = "";
        this.hand = []; //functionality for player 0 ONLY during setup
        this.handSize = num; //how many cards each player has
        this.cardCount = 0; //functionality ONLY for player 0 when selecting cards during setup
    }
}

class Move {
    constructor(type, player, involvedCards) {
        this.type = type; //0: passed, 1: reveal to other, 2: reveal to you
        this.player = player; //index of the involved player
        this.involvedCards = involvedCards; // indicies of involved cards
    }
}

class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

/*

Data is stored in a string

The first three spaces in the string are reserved for the target person, weapon, and room
Following that is player 1, player 2, etc.

*/

class LinkedList {
    constructor(head = null) {
        this.head = head;
        this.tail = head;
    }

    newNode(data) {
        //console.log("new node");
        if (this.head) {
            this.tail.next = new Node(data);
            this.tail = this.tail.next;
        } else {
            this.head = new Node(data);
            this.tail = this.head;
        }
    }

    updateNodes(toRemove) {

    }
}

function fact(n) {
    if (n == 0) {
        return 1;
    }
    var out = 1;
    for (var i = 1; i <= n; i++) {
        out *= i;
    }
    return out;
}

var playerCount = 0;
const players = []; //list of all of the players

let hands = new LinkedList();

const cards = []; //master list of cards with odds of being the murderer
const cardsLength = 21; //all of the cards in the game
const activeCards = 18; //all of the cards minus the ones removed
const convert = 64; // the ascii conversion
const cardsLeft = [6, 6, 9]; //the cards left in each type of card

const moves = []; //list of all player's actions


var totalCombinations = 0;


for (var i = 0; i < cardsLength; i++) {
    cards[i] = new Card(i);
}

//step 1:
function adjustPlayers(i) {
    playerCount += i;
    document.getElementById("playerCount").innerHTML = playerCount;
}

//step 2:
function setupGame() {
    document.getElementById("openDiv").style.display = "none";

    const setupDiv = document.getElementById("setupDiv");
    setupDiv.style.display = "block";

    for (var i = 0; i < playerCount; i++) {
        players[i] = new Player(Math.floor(18 / playerCount));

        const input = document.createElement("input");
        input.id = "playerInput" + i;
        setupDiv.appendChild(input);
        const down = document.createElement("button");
        down.setAttribute("onclick", "adjustCardCount(" + i + ", -1)");
        down.innerHTML = "\\/";
        const up = document.createElement("button");
        up.innerHTML = "/\\";
        up.setAttribute("onclick", "adjustCardCount(" + i + ", 1)");
        const disp = document.createElement("span");
        disp.innerHTML = " " + players[i].handSize + " ";
        disp.id = "playerCardCount" + i;        


        setupDiv.appendChild(down);
        setupDiv.appendChild(disp);
        setupDiv.appendChild(up);

        setupDiv.appendChild(document.createElement("br"));
        setupDiv.appendChild(document.createElement("br"));
    }

    for (var i = 0; i < cardsLength; i++) {
        const input = document.createElement("button");
        input.setAttribute("onclick", "selectAsOwn(" + i + ")");
        input.innerHTML = cardNames[i];

        setupDiv.appendChild(input);
        setupDiv.appendChild(document.createElement("br"));
    }
}
function adjustCardCount(i, n) {
    players[i].handSize += n;
    document.getElementById("playerCardCount" + i).innerHTML = " " + players[i].handSize + " ";

}
function selectAsOwn(index) {
    var removed = false;
    for (var i = 0; i < players[0].cardCount; i++) {
        if (players[0].hand[i].index == index) {
            players[0].hand.splice(i, 1);
            players[0].cardCount--;
            const selected = document.getElementById("selectedCard" + index);
            selected.parentNode.removeChild(selected);
            removed = true;
            cards[index].inHand = false;
        }
    }
    if (!removed) {
        players[0].hand[players[0].cardCount++] = new Card(index);
        cards[index].inHand = true;
        const selected = document.createElement("div");
        selected.id = "selectedCard" + index;
        selected.innerHTML = cardNames[index];
        document.getElementById("setupDiv").appendChild(selected);
    }

    //add start button if there is enough cards
    if (players[0].cardCount == players[0].handSize) {
        const startButton = document.createElement("button");
        startButton.innerHTML = "Start";
        startButton.id = "startButton";
        startButton.setAttribute("onclick", "startGame()");
        document.getElementById("setupDiv").appendChild(startButton);
    } else {
        const startButton = document.getElementById("startButton");
        if (startButton != null) {
            startButton.parentNode.removeChild(startButton);
        }
    }
}

/*
function genPossibilities(str, i, arr2) {
    arr = [...arr2];
    if (i == cardsLength) {
        hands.newNode(str);
        return;
    }

    if (cards[i].inHand) {
        arr[0]--;
        genPossibilities(str+"@", i+1, arr);
    } else {
        if (str.indexOf(String.fromCharCode(cards[i].type+61)) == -1) {
            genPossibilities(str+String.fromCharCode(cards[i].type+61), i+1, arr);
        }
        for (var l = 1; l < playerCount; l++) {
            if (l != 1) {
                arr[l-1]++;
            }
            arr[l]--;
            if (arr[l] >= 0) {
                genPossibilities(str+String.fromCharCode(l+64), i+1, arr);
            }
        }
    }
}
*/

function startGame() {
    //find total combinations

    //handle player 0
    /*
    for (var i = 0; i < players[0].handSize; i++) {
        cardsLeft[players[0].hand[i].type]--;
    }


    totalCombinations = cardsLeft[0] * cardsLeft[1] * cardsLeft[2]; //combinations of outcomes

    var usedCards = players[0].handSize;
    for (var i = 1; i < playerCount; i++) {
        totalCombinations *= combination(activeCards-usedCards, players[i].handSize); //fact(activeCards-usedCards)/(fact(activeCards-usedCards-players[i].handSize) * fact(players[i].handSize));
        usedCards += players[i].handSize;
    }
    console.log(totalCombinations);
    */
    arr = [];
    for (var i = 0; i < playerCount; i++) {
        arr[i] = players[i].handSize;
    }
    var x = 0;
    for (var i = 0; i < Math.pow(playerCount, 21); i++) {
        x+=5;
    }
    /*
    //create all the base possibilities for each card
    for (var i = 0; i < cardsLength; i++) {

        //scenarios of being chosen card
        cards[i].odd = totalCombinations/cards[i].count;

        //scenarios of being in l player's hand
        for (var l = 0; l < playerCount; l++) {
            cards[i].odds[l] = (totalCombinations-cards[i].odd) * (players[l].handSize/activeCards);
        }

    }
    */
   console.log("success!");
    return;
   updateOdds();
    printOdds();
    return;
    //remove all possibilities where player 0 does not have the card
    for (var i = 0; i < players[0].handSize; i++) {
        addCard(players[0].hand[i].index, 0);
    }

    printOdds();

    //newMove(0, 1, [9]);

    //printOdds();
}

function combination(a, b) {
    if (b > a) {
        var temp = b;
        b = a;
        a = temp;
    }
    if (b == 0) {
        return 0;
    }
    return fact(a) / (fact(a - b)*fact(b));
}

function addCard(index, player) {

    totalCombinations = cards[index].odds[player];
    //remove possibilities from said player
    for (var i = 0; i < playerCount; i++) {
        if (i != player) {
            cards[index].odds[i] = 0;
        }
    }

    for (var i = 0; i < cardsLength; i++) {
        if (i != index) {
            for (var l = 0; l < playerCount; l++) {
                if (l == player) {
                    //subtract all the ways that A and B exist outside of player's hand
                    //by finding all the combinations of not A and not B that can fit in player's hand
                    cards[i].odds[l] -= combination(cardsLength - 2, players[l].handSize);
                } else {
                    //subtract all the ways A exists outside and B exists in the hand
                    cards[i].odds[l] -= combination(cardsLength - 1, players[l].handSize-1);
                }
            }
        }
    }
}

function newMove(moveType, player, involvedCards) {
    if (moveType == 0) { //pass
        for (var i = 0; i < involvedCards.length; i++) {
            const card = cards[involvedCards[i]];
            console.log(card.denominator);
            //that player's odds are now 0
            var amountRemoved = card.odds[player];
            card.odds[player] = 0;

            //remove the hand size (removed possible places) of the player that does not have that card
            //look at definition of the denominator, where in denominator terms the value of each card slot is the cards left of that type
            card.denominator -= amountRemoved;
            //adjust denominators of other cards accordinly
            cards.forEach(card2 => {
                if (card2.index != card.index && !card2.playerHasCard) {
                    for (var l = 0; l < playerCount; l++) {
                        if (l == player) {
                            //increase odds since card was removed
                            card2.denominatorMod[l] -= cardsLeft[card2.type];
                        } else {
                            //decrease odds since hard has increased odds to be here
                            card2.denominatorMod[l] += cardsLeft[card2.type];
                        }
                    }
                }
            });
        };
    }
}

function updateOdds() {
    totalCombinations = 0;
    let crawler = hands.head;
    while (crawler) {
        for (var i = 0; i < cardsLength; i++) {
            cards[i].odds[crawler.data.charCodeAt(i)-64]++;
        }
        totalCombinations++;
        crawler = crawler.next;
    }
}

function printOdds() {
    const output = document.createElement("div");
    cards.forEach(card => {
        output.innerHTML += card.name + ": ";
        for (var i = 0; i < playerCount; i++) {
            output.innerHTML += (card.odds[i]/totalCombinations) + ", ";
        }
        output.innerHTML += "<br>";
    });
    document.getElementById("setupDiv").appendChild(output);
}

</script>
</head>
<body>
<!-- ===================HTML====================== -->
<div id="openDiv">
    <button onClick="adjustPlayers(1)">/\</button>
    <div id="playerCount">0</div>
    <button onClick="adjustPlayers(-1)">\/</button>
    <button onclick="setupGame()">Start</button>
</div>

<div id="setupDiv" style="display: none">
    <div>You:</div>
</div>

</body>
</html>